generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// generator zod {
//   provider          = "prisma-zod-generator"
//   output            = "../src/db/validation"
//   isGenerateSelect  = true
//   isGenerateInclude = true
// }

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?  @db.Text
  userAgent String?  @db.Text
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String    @db.Text
  providerId            String    @db.Text
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?   @db.Text
  password              String?   @db.Text
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id @default(cuid())
  identifier String    @db.Text
  value      String    @db.Text
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model User {
  id              String  @id @default(cuid())
  email           String
  emailVerified   Boolean
  username        String? @db.VarChar(100)
  displayUsername String?

  role User_Role @default(USER)
  type User_Type @default(MODEL)

  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  profile   Profile?
  name      String    @db.Text
  image     String?   @db.Text
  sessions  Session[]
  accounts  Account[]

  // Referral system
  referralCode  String? @unique @db.VarChar(50)
  referredById  String?
  referredBy    User?   @relation("Referrals", fields: [referredById], references: [id], onDelete: SetNull)
  referrals     User[]  @relation("Referrals")
  referralCount Int     @default(0)

  @@unique([email])
  @@unique([username])
  @@fulltext([name])
  @@fulltext([email])
  @@fulltext([displayUsername])
  @@fulltext([username])
  @@fulltext([name, email])
  @@map("user")
}

model Profile {
  id String @id @default(cuid())

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  bio       String? @db.Text
  instagram String? @db.VarChar(255)
  tiktok    String? @db.VarChar(255)
  youtube   String? @db.VarChar(255)
  facebook  String? @db.VarChar(255)
  twitter   String? @db.VarChar(255)
  linkedin  String? @db.VarChar(255)
  website   String? @db.VarChar(255)
  other     String? @db.VarChar(255)

  phone String? @db.VarChar(20)

  address     String
  city        String?   @db.VarChar(100)
  country     String?   @db.VarChar(100)
  postalCode  String?   @db.VarChar(20)
  dateOfBirth DateTime?
  gender      String?   @db.VarChar(50)

  hobbiesAndPassions    String?                @db.Text
  paidVoterMessage      String?                @db.Text
  freeVoterMessage      String?                @db.Text
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  contestParticipations ContestParticipation[] @relation("ProfileContestParticipations")

  contestWon Contest[]

  votesCast       Vote[]    @relation("VotesCast")
  votesReceived   Vote[]    @relation("VotesReceived")
  lastFreeVoteAt  DateTime?

  // ONE cover image
  coverImageId String? @unique
  coverImage   Media?  @relation("ProfileCoverImage", fields: [coverImageId], references: [id], onDelete: Cascade)

  // NEW: ONE banner image
  bannerImageId String? @unique
  bannerImage   Media?  @relation("ProfileBannerImage", fields: [bannerImageId], references: [id], onDelete: Cascade)

  // MULTIPLE profile gallery images
  profilePhotos Media[] @relation("ProfilePhotos")

  rank Rank? @relation("ProfileRank")

  notification Notification[]

  payments         Payment[]
  stats            ProfileStats?
  paymentsReceived Payment[]     @relation("PaymentIntendedVotee")

  // Favorites (as a voter)
  favoriteModels   Favorite[] @relation("VoterFavorites")
  // Favorited by (as a model)
  favoritedBy      Favorite[] @relation("ModelFavorites")

  @@fulltext([bio])
  @@fulltext([hobbiesAndPassions])
  @@fulltext([paidVoterMessage])
  @@fulltext([freeVoterMessage])
  @@fulltext([city])
  @@fulltext([country])
  @@fulltext([bio, city, country, hobbiesAndPassions, paidVoterMessage, freeVoterMessage])
}

// Favorite models (voters favoriting models)
model Favorite {
  id String @id @default(cuid())

  voterId String
  voter   Profile @relation("VoterFavorites", fields: [voterId], references: [id], onDelete: Cascade)

  modelId String
  model   Profile @relation("ModelFavorites", fields: [modelId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([voterId, modelId])
  @@index([voterId])
  @@index([modelId])
  @@map("favorites")
}

model ProfileStats {
  profileId String  @id
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  /// Count of free votes
  freeVotes Int @default(0)

  /// Count of paid votes
  paidVotes Int @default(0)

  /// Weighted score (paidVoteWeight * paidVotes + freeVoteWeight * freeVotes)
  weightedScore Int @default(0)

  lastUpdated DateTime @default(now()) @updatedAt
}

model Rank {
  id String @id @default(cuid())

  manualRank   Int? @unique
  computedRank Int? @unique

  profileId String  @unique
  profile   Profile @relation("ProfileRank", fields: [profileId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([computedRank])
  @@map("rank")
}

model Notification {
  id         String            @id @default(uuid())
  title      String?
  message    String
  profile    Profile           @relation(fields: [profileId], references: [id], onDelete: Cascade)
  profileId  String
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  isRead     Boolean           @default(false)
  isArchived Boolean           @default(false)
  icon       Icon?             @default(INFO)
  action     String?
  type       Notification_Type @default(SYSTEM)

  @@index([profileId])
}

enum Notification_Type {
  COMPETITION_JOINED
  COMPETITION_LEFT
  COMPETITION_CREATED
  COMPETITION_UPCOMING
  VOTE_RECEIVED
  VOTE_PREMIUM
  SETTINGS_CHANGED
  REMINDER
  TIP
  MOTIVATION
  SYSTEM
}

enum Icon {
  WARNING
  SUCCESS
  INFO
}

enum Contest_Status {
  DRAFT
  PUBLISHED
  ACTIVE
  BOOKED
  VOTING
  JUDGING
  COMPLETED
  CANCELLED
  SUSPENDED
}

enum Contest_Visibility {
  PUBLIC
  PRIVATE
  INVITE_ONLY
  RESTRICTED
}

model Contest {
  id          String @id @default(cuid())
  name        String @db.VarChar(255)
  description String @db.LongText
  prizePool   Float  @db.Float()

  // Relations
  contestParticipations ContestParticipation[] @relation("ContestParticipants")
  awards                Award[]
  votes                 Vote[]
  winner                Profile?               @relation(fields: [winnerProfileId], references: [id], onDelete: SetNull)
  winnerProfileId       String?
  images                Media[]                @relation("ContestImages")

  // Dates
  startDate            DateTime
  endDate              DateTime
  registrationDeadline DateTime?
  resultAnnounceDate   DateTime?

  // Metadata
  slug            String             @unique
  status          Contest_Status     @default(DRAFT)
  visibility      Contest_Visibility @default(PUBLIC)
  isFeatured      Boolean            @default(false)
  isVerified      Boolean            @default(false)
  isVotingEnabled Boolean            @default(false)

  // Rules & Requirements
  rules        String? @db.LongText
  requirements String? @db.LongText

  // Audit
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  payments  Payment[] @relation("PaymentIntendedContest")

  // Indexes
  @@index([status])
  @@index([visibility])
  @@index([startDate, endDate])
  @@index([isFeatured])
  @@index([slug])
  // Full-text search
  @@fulltext([name])
  @@fulltext([description])
  @@fulltext([name, description])
}

model Award {
  id   String @id @default(cuid())
  name String
  icon String

  contestId String
  contest   Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@unique([name, icon, contestId])
  @@map("contest_awards")
}

model Vote {
  id String @id @default(cuid())

  type Vote_Type @default(FREE)

  comment String? @db.Text

  voterId String
  voter   Profile @relation("VotesCast", fields: [voterId], references: [id], onDelete: Cascade)

  voteeId String
  votee   Profile @relation("VotesReceived", fields: [voteeId], references: [id], onDelete: Cascade)

  contestId String
  contest   Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  count     Int     @default(1)

  paymentId String?
  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contestId, voteeId, type])
  @@index([contestId, type])
}

enum Vote_Type {
  FREE
  PAID
}

model VoteMultiplierPeriod {
  id              String   @id @default(cuid())
  startTime       DateTime
  endTime         DateTime
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  multiplierTimes Int      @default(2)

  @@map("vote_multiplier_period")
}

model ContestParticipation {
  id        String @id @default(cuid())
  profileId String
  contestId String

  profile Profile @relation("ProfileContestParticipations", fields: [profileId], references: [id], onDelete: Cascade)
  contest Contest @relation("ContestParticipants", fields: [contestId], references: [id], onDelete: Cascade)

  coverImage Media?  @relation("ContestParticipationCoverImage", fields: [mediaId], references: [id], onDelete: SetNull)
  mediaId    String? @unique

  isApproved      Boolean  @default(false)
  isParticipating Boolean? @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([profileId, contestId])
  @@index([contestId])
  @@index([profileId])
  @@index([contestId, profileId])
  @@index([profileId, isParticipating])
  @@index([profileId, createdAt])
}

enum Contest_Participation_Status {
  PENDING
  APPROVED
  REJECTED
  WITHDRAWN
}

enum User_Role {
  USER
  MODERATOR
  ADMIN
}

enum User_Type {
  MODEL
  VOTER
}

model Media {
  id        String      @id @default(uuid())
  key       String
  name      String
  url       String
  size      Int?
  caption   String?
  type      String?
  status    File_Status @default(PROCESSING)
  mediaType Media_Type  @default(PROFILE_IMAGE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to Profile for gallery images
  profileId String?
  profile   Profile? @relation("ProfilePhotos", fields: [profileId], references: [id], onDelete: Cascade)

  // Relation to Profile as cover image (reverse relation defined in Profile)
  coverOfProfile Profile? @relation("ProfileCoverImage")

  // NEW: Relation to Profile as banner image
  bannerOfProfile Profile? @relation("ProfileBannerImage")

  // Relation to Contest for contest images
  contestId String?
  contest   Contest? @relation("ContestImages", fields: [contestId], references: [id], onDelete: Cascade)

  // Relation to ContestParticipation as cover image
  contestParticipationCover ContestParticipation? @relation("ContestParticipationCoverImage")

  @@map("media")
}

enum Media_Type {
  COVER_IMAGE
  CONTEST_IMAGE
  CONTEST_PARTICIPATION_COVER
  PROFILE_IMAGE
  PROFILE_COVER_IMAGE
  PROFILE_BANNER_IMAGE
}

enum File_Status {
  FAILED
  PROCESSING
  COMPLETED
}

model Payment {
  id String @id @default(cuid())

  payerId String
  payer   Profile @relation(fields: [payerId], references: [id], onDelete: Cascade)

  amount Float
  status Payment_Status @default(PENDING)
  type   Payment_Type   @default(MODEL_VOTE) // Type of payment

  votes Vote[]

  stripeSessionId String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Intent fields (who/what payment is for)
  intendedVoteeId String?
  intendedVotee   Profile? @relation("PaymentIntendedVotee", fields: [intendedVoteeId], references: [id], onDelete: SetNull)

  intendedContestId String?
  intendedContest   Contest? @relation("PaymentIntendedContest", fields: [intendedContestId], references: [id], onDelete: SetNull)

  intendedVoteCount Int?
  intendedComment   String? @db.Text
}

enum Payment_Status {
  PENDING
  COMPLETED
  FAILED
}

enum Payment_Type {
  MODEL_VOTE      // Direct vote purchase for a specific model
}

// Configuration table for referral tiers
model ReferralTier {
  id String @id @default(cuid())
  
  minReferrals Int // Minimum referrals needed for this tier
  maxReferrals Int? // Maximum referrals (null for highest tier)
  tierName     String @db.VarChar(100)
  tierLevel    Int // 1 = Bronze, 2 = Silver, etc.
  reward       String @db.Text
  description  String? @db.Text
  icon         String? @db.VarChar(100)
  color        String? @db.VarChar(50)
  isActive     Boolean @default(true)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tierLevel])
  @@index([minReferrals])
  @@index([isActive])
  @@map("referral_tier")
}
